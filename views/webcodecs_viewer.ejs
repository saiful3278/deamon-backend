<!DOCTYPE html>
<html>
  <head>
    <title>WebCodecs Viewer <%= id %></title>
    <%- include('partials/layout') %>
  </head>
  <body>
    <div class="container">
      <div id="header">
        <div class="status-bar">
          <div class="status-left">
            <span class="dot" id="wsdot"></span>
            <span><%= id %></span>
            <span id="status">Disconnected</span>
          </div>
        </div>
        <%- include('partials/controls') %>
        <div class="stream-controls">
          <button class="btn" id="start">Start</button>
          <button class="btn" id="stop">Stop</button>
        </div>
      </div>
      
      <div class="stream-box">
        <canvas id="canvas" class="viewer"></canvas>
        <div id="stats" class="overlay-stats"></div>
        <div id="error" class="overlay-error"></div>
      </div>
      
      <div id="log" class="log-panel"></div>
      
      <style>
        .modal-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999; justify-content:center; align-items:center; backdrop-filter: blur(5px); }
        .modal-box { background:#1e1e1e; padding:25px; border-radius:12px; width:400px; color:#e0e0e0; box-shadow: 0 10px 25px rgba(0,0,0,0.5); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        .modal-title { margin-top:0; margin-bottom:20px; font-size:1.25rem; font-weight:600; color:#fff; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .setting-group { margin-bottom:20px; }
        .setting-label { display:block; margin-bottom:8px; font-size:0.9rem; color:#aaa; font-weight: 500; }
        .preset-container { display:flex; gap:8px; flex-wrap:wrap; }
        .preset-btn { flex:1; padding:8px 12px; background:#2a2a2a; border:1px solid #444; color:#ccc; border-radius:6px; cursor:pointer; transition: all 0.2s; font-size: 0.9rem; text-align: center; }
        .preset-btn:hover { background:#3a3a3a; border-color:#555; }
        .preset-btn.active { background:#007bff; border-color:#007bff; color:#fff; font-weight: 600; }
        .action-row { display:flex; justify-content:flex-end; gap:12px; margin-top:25px; pt: 15px; border-top: 1px solid #333; }
        .btn-modal { padding: 10px 20px; border-radius: 6px; border: none; cursor: pointer; font-weight: 600; font-size: 0.95rem; transition: opacity 0.2s; }
        .btn-cancel { background: transparent; color: #aaa; }
        .btn-cancel:hover { color: #fff; background: #333; }
        .btn-confirm { background: #007bff; color: white; }
        .btn-confirm:hover { opacity: 0.9; }
      </style>

      <div id="settings-modal" class="modal-overlay">
        <div class="modal-box">
          <h3 class="modal-title">Stream Configuration</h3>
          
          <!-- Resolution -->
          <div class="setting-group">
            <label class="setting-label">Resolution</label>
            <div class="preset-container" id="res-presets">
              <div class="preset-btn" onclick="selectPreset('res', 480)">480p</div>
              <div class="preset-btn active" onclick="selectPreset('res', 720)">720p</div>
              <div class="preset-btn" onclick="selectPreset('res', 1080)">1080p</div>
            </div>
            <input type="hidden" id="val-res" value="720">
          </div>

          <!-- Bitrate -->
          <div class="setting-group">
            <label class="setting-label">Bitrate</label>
            <div class="preset-container" id="bit-presets">
              <div class="preset-btn" onclick="selectPreset('bit', 2000000)">2M</div>
              <div class="preset-btn active" onclick="selectPreset('bit', 4000000)">4M</div>
              <div class="preset-btn" onclick="selectPreset('bit', 8000000)">8M</div>
              <div class="preset-btn" onclick="selectPreset('bit', 16000000)">16M</div>
            </div>
            <input type="hidden" id="val-bit" value="4000000">
          </div>

          <!-- FPS -->
          <div class="setting-group">
            <label class="setting-label">Frame Rate (FPS)</label>
            <div class="preset-container" id="fps-presets">
              <div class="preset-btn" onclick="selectPreset('fps', 30)">30</div>
              <div class="preset-btn active" onclick="selectPreset('fps', 60)">60</div>
            </div>
            <input type="hidden" id="val-fps" value="60">
          </div>

          <div class="action-row">
             <button class="btn-modal btn-cancel" onclick="closeSettings()">Cancel</button>
             <button class="btn-modal btn-confirm" onclick="confirmStart()">Start Stream</button>
          </div>
        </div>
      </div>

    </div>
    <script>
      const id = '<%= id %>'
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:'
      const ws = new WebSocket(protocol + '//' + location.host + '/ws')
      ws.binaryType = 'arraybuffer'
      
      const canvas = document.getElementById('canvas')
      const ctx = canvas.getContext('2d')
      
      // State
      let decoder = null
      let frameQueue = []
      let pendingChunks = [] // For accumulating fragmented NALs
      let hasConfig = false
      let sps = null
      let pps = null
      let frameCount = 0
      
      function log(t){ try { console.log('[viewer]', t) } catch (_) {} try { const el = document.getElementById('log'); const p = document.createElement('div'); p.textContent = typeof t==='string'?t:JSON.stringify(t); el.appendChild(p); el.scrollTop = el.scrollHeight } catch (_) {} }
      function setStatus(t){ document.getElementById('status').textContent = t; }
      function setWs(ok){ const d = document.getElementById('wsdot'); if (d) d.className = 'dot' + (ok ? ' ok' : '') }
      function setError(t){ const el = document.getElementById('error'); el.textContent = t; el.style.display = 'block' }

      // WebCodecs Setup
      function initDecoder() {
        if (decoder) return
        if (!window.VideoDecoder) { setError('WebCodecs API not supported'); return }
        
        decoder = new VideoDecoder({
          output: (frame) => {
            frameCount++
            // Render immediately (simple queue)
            // In a real player you'd sync to audio or wall clock
            if (canvas.width !== frame.displayWidth || canvas.height !== frame.displayHeight) {
              canvas.width = frame.displayWidth
              canvas.height = frame.displayHeight
            }
            ctx.drawImage(frame, 0, 0)
            frame.close()
            setStatus('Playing: ' + frameCount + ' frames')
          },
          error: (e) => {
            setError('Decoder error: ' + e.message)
            log('Decoder error: ' + e.message)
            resetDecoder()
          }
        })
        log('Decoder initialized')
      }
      
      function resetDecoder() {
        if (decoder) {
          try {
            if (decoder.state === 'configured') decoder.flush().catch(()=>{})
          } catch(e){}
          try { decoder.close() } catch(e){}
          decoder = null
        }
        hasConfig = false
        sps = null
        pps = null
        initDecoder()
      }

      function configureDecoder(sps, pps) {
        if (!decoder || hasConfig) return
        
        // Build AVCC (AVCDecoderConfigurationRecord) for description
        const avcc = buildAvcC(sps, pps)
        
        // Parse profile/level from SPS for codec string
        // Profile: sps[1], Level: sps[3]
        const profile = sps[1]
        const level = sps[3]
        const codec = 'avc1.' + toHex(profile) + '00' + toHex(level) // e.g. avc1.42001f
        
        try {
          decoder.configure({
            codec: codec,
            description: avcc,
            optimizeForLatency: true
          })
          hasConfig = true
          log('Decoder configured: ' + codec)
        } catch (e) {
          setError('Config error: ' + e.message)
        }
      }

      // NALU Parser
      let buffer = new Uint8Array(0)
      
      function appendBuffer(chunk) {
        const newBuf = new Uint8Array(buffer.length + chunk.length)
        newBuf.set(buffer)
        newBuf.set(chunk, buffer.length)
        buffer = newBuf
      }
      
      function processBuffer() {
        // Find NAL start codes 00 00 00 01 or 00 00 01
        // We will assume 00 00 00 01 for simplicity as scrcpy/ffmpeg usually outputs that
        // But better to handle both.
        
        let offset = 0
        while (offset < buffer.length) {
          const nextStart = findStartCode(buffer, offset + 3) // optimize skip
          if (nextStart === -1) {
            // No more start codes, keep the remaining part in buffer (it might be start of next NAL)
            // But we must be careful not to keep too much if stream is corrupted
            if (buffer.length - offset > 1000000) {
              // Safety flush
              buffer = new Uint8Array(0)
            } else {
              buffer = buffer.slice(offset)
            }
            break
          }
          
          // Found a NAL unit from offset to nextStart
          const nalUnit = buffer.slice(offset, nextStart)
          
          // Remove start code emulation prevention bytes? 
          // Raw NALs from network usually have them. Decoder expects them?
          // WebCodecs expects RBSP or NAL? 
          // Usually AVCC format stores NALs as is (with emulation bytes).
          
          // Strip start code (3 or 4 bytes)
          let startLen = 0
          if (nalUnit[0] === 0 && nalUnit[1] === 0) {
             if (nalUnit[2] === 1) startLen = 3
             else if (nalUnit[2] === 0 && nalUnit[3] === 1) startLen = 4
          }
          
          if (startLen > 0) {
            const payload = nalUnit.slice(startLen)
            handleNal(payload)
          }
          
          offset = nextStart
        }
      }
      
      function findStartCode(buf, from) {
        for (let i = from; i < buf.length - 3; i++) {
          if (buf[i] === 0 && buf[i+1] === 0) {
            if (buf[i+2] === 1) return i
            if (buf[i+2] === 0 && buf[i+3] === 1) return i
          }
        }
        return -1
      }
      
      function handleNal(nal) {
        const type = nal[0] & 0x1f
        
        if (type === 7) { // SPS
          sps = nal
          log('Got SPS: ' + nal.length)
          if (pps) configureDecoder(sps, pps)
        } else if (type === 8) { // PPS
          pps = nal
          log('Got PPS: ' + nal.length)
          if (sps) configureDecoder(sps, pps)
        } else if (type === 1 || type === 5) { // Slice
          if (!hasConfig && sps && pps) configureDecoder(sps, pps)
          if (!hasConfig) return // Wait for config
          
          const isKey = (type === 5)
          
          // Prepare chunk for WebCodecs
          // Needs to be in AVCC format (length prefixed)? 
          // Or Annex B?
          // The spec says for 'avc1', usage of EncodedVideoChunk depends on description.
          // But generally `decoder.decode` expects the data format to match.
          // If we provided `description` (AVCC), it expects AVCC formatted NALs (length-prefixed).
          
          const len = nal.length
          const chunkData = new Uint8Array(4 + len)
          const view = new DataView(chunkData.buffer)
          view.setUint32(0, len, false) // Big Endian length
          chunkData.set(nal, 4)
          
          try {
            const chunk = new EncodedVideoChunk({
              type: isKey ? 'key' : 'delta',
              timestamp: frameCount * 16666, // Synthetic timestamp ~60fps
              data: chunkData
            })
            decoder.decode(chunk)
          } catch (e) {
            console.error(e)
            log('Decode error: ' + e.message)
          }
        }
      }

      // Helpers
      function buildAvcC(sps, pps){
        const profile = sps[1]
        const compat = sps[2]
        const level = sps[3]
        const spsLen = sps.length
        const ppsLen = pps.length
        const out = new Uint8Array(7 + 2 + spsLen + 1 + 2 + ppsLen)
        let o = 0
        out[o++] = 1 // configurationVersion
        out[o++] = profile
        out[o++] = compat
        out[o++] = level
        out[o++] = 0xff // lengthSizeMinusOne | 0xFC = 3 bytes (size 4) -> 0xFF
        out[o++] = 0xe1 // numOfSPS (1) | 0xE0
        out[o++] = (spsLen>>>8)&0xff
        out[o++] = spsLen&0xff
        out.set(sps, o); o += spsLen
        out[o++] = 1 // numOfPPS
        out[o++] = (ppsLen>>>8)&0xff
        out[o++] = ppsLen&0xff
        out.set(pps, o)
        return out
      }
      
      function toHex(n) { return n.toString(16).toUpperCase().padStart(2, '0') }

      // WS Events
      ws.addEventListener('open', () => {
        setStatus('Connected')
        setWs(true)
        log('ws open')
        initDecoder()
        
        ws.send(JSON.stringify({ type: 'viewer', id }))
        
        // Request annexb mode (raw H.264)
        setTimeout(() => {
            ws.send(JSON.stringify({ type:'mode', id, mode:'annexb' }))
            log('Requested annexb mode')
        }, 100)
      })
      
      ws.addEventListener('message', (ev) => {
        if (typeof ev.data === 'string') {
          // Control messages
          try {
             const msg = JSON.parse(ev.data)
             if (msg.type === 'mode') log('Mode: ' + msg.mode)
          } catch(e){}
        } else if (ev.data instanceof ArrayBuffer) {
          // Video Data
          appendBuffer(new Uint8Array(ev.data))
          processBuffer()
        }
      })
      
      ws.addEventListener('close', () => { setWs(false); setStatus('Disconnected'); log('ws close') })
      ws.addEventListener('error', (e) => { log('ws error ' + e.message) })

      document.getElementById('start').onclick = () => {
        // Show settings modal
        document.getElementById('settings-modal').style.display = 'flex'
      }

      function selectPreset(type, val) {
        document.getElementById('val-'+type).value = val
        const container = document.getElementById(type+'-presets')
        const btns = container.getElementsByClassName('preset-btn')
        for(let b of btns) b.classList.remove('active')
        if (window.event && window.event.currentTarget) {
          window.event.currentTarget.classList.add('active')
        }
      }

      function closeSettings() {
        document.getElementById('settings-modal').style.display = 'none'
      }

      function confirmStart() {
        closeSettings()
        const size = parseInt(document.getElementById('val-res').value) || 720
        const bitrate = parseInt(document.getElementById('val-bit').value) || 4000000
        const fps = parseInt(document.getElementById('val-fps').value) || 60
        log('starting with size='+size+' bitrate='+bitrate+' fps='+fps)
        fetch('/device/'+id+'/start', { 
            method:'POST', 
            headers:{'Content-Type':'application/json'}, 
            body: JSON.stringify({ maxSize: size, bitrate: bitrate, maxFps: fps }) 
        }).catch(e=>log('start error ' + e.message))
      }
      
      document.getElementById('stop').onclick = () => {
        log('stop clicked')
        fetch('/device/'+id+'/stop', { method:'POST' }).catch(e=>log('stop error ' + e.message))
      }

      function modeProvider(m){
          if (m === 'fmp4') location.href = '/view/'+id
      }
      window.initControls && window.initControls({ ws, canvas, id, modeProvider })

      // Input Handling
      function sendTouch(action, e) {
        if (ws.readyState !== WebSocket.OPEN) return
        const rect = canvas.getBoundingClientRect()
        let cx, cy;
        if (e.touches && e.touches.length > 0) {
            cx = e.touches[0].clientX
            cy = e.touches[0].clientY
        } else {
            cx = e.clientX
            cy = e.clientY
        }
        
        const ratioX = (cx - rect.left) / rect.width
        const ratioY = (cy - rect.top) / rect.height
        const w = canvas.width
        const h = canvas.height
        const x = Math.round(ratioX * w)
        const y = Math.round(ratioY * h)
        
        const buf = new ArrayBuffer(32)
        const view = new DataView(buf)
        view.setUint8(0, 2) // INJECT_TOUCH_EVENT
        view.setUint8(1, action) // 0:down, 1:up, 2:move
        view.setBigUint64(2, 0n) // pointerId
        view.setInt32(10, x)
        view.setInt32(14, y)
        view.setUint16(18, w)
        view.setUint16(20, h)
        view.setUint16(22, action === 1 ? 0 : 65535) // pressure
        view.setInt32(24, action === 1 ? 0 : 1)
        view.setInt32(28, action === 1 ? 0 : 1)
        ws.send(buf)
      }

      canvas.addEventListener('mousedown', (e) => {
        sendTouch(0, e) // DOWN
        const onMove = (ev) => sendTouch(2, ev) // MOVE
        const onUp = (ev) => {
          sendTouch(1, ev) // UP
          document.removeEventListener('mousemove', onMove)
          document.removeEventListener('mouseup', onUp)
        }
        document.addEventListener('mousemove', onMove)
        document.addEventListener('mouseup', onUp)
      })
      
      canvas.addEventListener('touchstart', (e) => {
          sendTouch(0, e)
      }, {passive: false})
      canvas.addEventListener('touchmove', (e) => {
          sendTouch(2, e)
      }, {passive: false})
      canvas.addEventListener('touchend', (e) => {
          sendTouch(1, e) // UP
      }, {passive: false})
      
      // Prevent context menu on right click
      canvas.addEventListener('contextmenu', (e) => { e.preventDefault() })

      const KEY_MAP = {
        'Enter': 66, 'Backspace': 67, 'Escape': 111, 'Home': 3, 'ArrowUp': 19, 'ArrowDown': 20, 'ArrowLeft': 21, 'ArrowRight': 22,
        'a': 29, 'b': 30, 'c': 31, 'd': 32, 'e': 33, 'f': 34, 'g': 35, 'h': 36, 'i': 37, 'j': 38, 'k': 39, 'l': 40, 'm': 41,
        'n': 42, 'o': 43, 'p': 44, 'q': 45, 'r': 46, 's': 47, 't': 48, 'u': 49, 'v': 50, 'w': 51, 'x': 52, 'y': 53, 'z': 54,
        ' ': 62, '0': 7, '1': 8, '2': 9, '3': 10, '4': 11, '5': 12, '6': 13, '7': 14, '8': 15, '9': 16
      }
      
      window.addEventListener('keydown', (e) => {
        const code = KEY_MAP[e.key] || KEY_MAP[e.key.toLowerCase()]
        if (!code) return
        const buf = new ArrayBuffer(14)
        const view = new DataView(buf)
        view.setUint8(0, 0) // INJECT_KEYCODE
        view.setUint8(1, 0) // DOWN
        view.setInt32(2, code)
        view.setInt32(6, 0) // repeat
        view.setInt32(10, 0) // meta
        ws.send(buf)
      })
      
      window.addEventListener('keyup', (e) => {
        const code = KEY_MAP[e.key] || KEY_MAP[e.key.toLowerCase()]
        if (!code) return
        const buf = new ArrayBuffer(14)
        const view = new DataView(buf)
        view.setUint8(0, 0) // INJECT_KEYCODE
        view.setUint8(1, 1) // UP
        view.setInt32(2, code)
        view.setInt32(6, 0)
        view.setInt32(10, 0)
        ws.send(buf)
      })

    </script>
  </body>
</html>
